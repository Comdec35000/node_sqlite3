const childprocess = require("child_process");
const fs = require('fs');
const path = require('path');
const QueryResponse = require("./query_response");
const SQLiteError = require('./sqlite_error');


module.exports = class Connection {
  /**
   * 
   * @param {path} addr The path to the database file 
   */
  constructor(addr) {

    if(!addr || typeof addr != 'string')
      throw new Error('Invalid database address : ' + addr);

    // Format the path to an absolute path
    if(!path.isAbsolute(addr)) addr = path.join(process.cwd(), addr);

    // Check the extention of the file targetted
    if(!(path.extname(addr) === ".db")) {
      
      // Checks if the file has an extension
      if(path.extname(addr)) 
        throw new Error('The database file should end with the \'.db\' extensiton ! Current is : ' + path.extname(addr));
    
      addr += ".db";  
    }

    this.addr = addr;
    
    this.createDirTree();
  }

  /**
   * Create recursively the folder tree for the database file
   */
  createDirTree() {
    const dir = this.addr.split(path.sep);
    dir.shift();
    dir.pop();

    const cwd = process.cwd();
    this.createDir(path.parse(this.addr).root + dir.shift(), dir);

    if(!fs.existsSync(this.addr)) fs.writeFileSync(this.addr, '');
    
    process.chdir(cwd);
  }

  createDir(dirname, list) {
    process.chdir(dirname);

    const next = list.shift();
    const nextPath = path.join(process.cwd(), next)

    if(!fs.existsSync(nextPath)) fs.mkdirSync(nextPath)
    if(list.length > 0) this.createDir(next, list);
  }


  /**
   * Run an SQL query, otpionally with specific arguments
   * @param {string} sql An SQL query or mutation
   * @param {Array<string>} args (optional) An array of arguments to replace the "?" in the query
   * @returns A QueryResonse object witch contains the rows or the errors generated by the SQL code inputed
   */
  async runSql(sql, args) {

    if(args) args.forEach(arg => {
      sql = sql.replace('?', p => typeof p == 'string' ? `\"${arg}\"` : arg);
    });

    return new Promise((resolve, rejects) => {

      let python = null;
      try {
        python = childprocess.spawn("python", [path.join(__dirname, "../python/execute.py"), this.addr, sql]);
      } catch(e) {
        rejects(e);
      } finally {
        if(!python) rejects(new Error('Unable to call child process'));
      }
      const response = new QueryResponse();

      python.stdout.on('data', (data) => { 
        const rows = JSON.parse(data.toString('utf-8'))
        response.setRows(rows)
      })

      python.stderr.on('data', (err) => { 
        response.setError(new SQLiteError(err.toString('utf-8'), sql));
      });

      python.on('close', (code) => {
        if(response.error) throw(response.error);
        resolve(response);
      });
    })
  }


  /**
   * Used to run many times the same query with different arguments
   * @param {String} sql The SQL query you want to run with each of arguments set
   * @param {Array<Array<string>>} args An array of the Arry of arguments you want to run for each of the queries
   * @returns An array of QueryResponse
   */
  async runMany(sql, args) {

    const responses = []
    for(const arg of args) responses.push(await this.runSql(sql, arg));

    return responses;
  }

  async runFile(filePath) {
    if(!filePath || typeof filePath != 'string')
      throw new Error('Invalid SQL file path : ' + filePath);

    if(!path.isAbsolute(filePath)) filePath = path.join(process.cwd(), filePath);

    if(!(path.extname(filePath) === ".sql")) {
      
      if(path.extname(filePath)) 
        throw new Error('The SQL file should end with the \'.sql\' extensiton ! Current is : ' + path.extname(filePath));
    
        filePath += ".sql";  
    }

    const content = fs.readFileSync(filePath).toString('utf-8');
    const lines = content.split(/;/g);

    const responses = [];

    for(const line of lines) responses.push(await this.runSql(line));
    return responses;
  }

}
